#!/usr/bin/env python3
# vim: filetype=python

"""
Sender pipeline:
Unix socket/sound source
  --- samples stream ---> [Sample Reader]
  ---  sample_queue  ---> [Packetizer]
  ---> Uni/Multicast UDP

Receiver pipeline:
Socket
  ---  UDP datagrams  ---> [Receiver]
  --- chunks/commands ---> [ChunkPlayer]
  ---> pyaudio sink stream
"""
from time import time
import struct
import zlib
import socket
import random
from datetime import datetime, timedelta

import asyncio

from collections import deque

VERSION=(1, 1, 0)

class TimeMachine:
    """
    Handle fast millisecond precision timestamps

    `timemark' marks a time in future - certain number of milliseconds ahead of
    current time.
    """
    def get_timemark(self, latency):
        "Get a timemark `latency' ms in future"
        now = datetime.utcnow()
        stamp = (now.second * 1000) + (now.microsecond // 1000)
        # Stamp ranges from 0 to 59999 - fits in uint16_t
        stamp = (stamp + latency) % 59999
        stamp = struct.pack('>H', stamp)
        return now.timestamp() + latency/1000, stamp

    def to_absolute_timestamp(self, mark):
        now = datetime.utcnow()
        mark = struct.unpack('>H', mark)[0]
        second = mark // 1000
        microsecond = (mark % 1000) * 1000

        orig_now = now

        """
        Full cases in case time is not synchronised correctly in the network.
        ns           s
        now.second | second | solution     | Why
        0          | 1      | same minute  | s > ns, s-ns < 30
        0          | 59     | prev minute  | s > ns, s-ns > 30
        59         | 1      | next minute  | s < ns, ns-s > 30
        59         | 50     | same minute  | s < ns, ns-s < 30
        """

        if second > now.second:
            d = second - now.second
            if d < 30:
                # Same minute
                pass
            else:
                # Prev minute, won't be playing that I guess anyway
                now = now.replace(second=0, microsecond=0) + timedelta(minutes=-1)
        else:
            d = now.second - second
            if d > 30:
                # next minute
                now = now.replace(second=0, microsecond=0) + timedelta(minutes=1)
            else:
                # same minute
                pass

        absolute_mark = now.replace(second=second, microsecond=microsecond)

        return absolute_mark.timestamp()


class SampleReader(asyncio.Protocol):
    """Read samples over the network, chunk them and put into a queue"""

    # Number of empty chunks before silence is detected.
    SILENCE_TRESHOLD = 20
    HEADER_SIZE = 4

    def __init__(self):
        super().__init__()
        self.sample_queue = asyncio.Queue()

        self.silence_detect = 0

    def set_chunk_size(self, payload_size, sample_size):
        "Calculate optimal chunk size"
        # 1420 is max payload for UDP over 1500 MTU ethernet
        # 80 - max IP header (60) + UDP header.
        # 4 - our header / timestamp
        # NOTE: 60 bytes is pessimistically large IP header. Could be as
        #       small as 20 bytes.

        # Remove our header from the max payload size
        self.chunk_size = payload_size - self.HEADER_SIZE

        # To fit always the same amount of both channels (to not swap them in case
        # of a packet drop) ensure the amount of space is divisible by sample_size
        self.chunk_size -= self.chunk_size % sample_size

        # Required for MTU detection
        self.sample_size = sample_size

    def connection_made(self, transport):
        "Initialize stream buffer"
        self.buffer = bytes()

    def data_received(self, data):
        "Read fifo indefinitely and push data into queue"

        # NOTE: Buffer needs to be only twice the size of the data
        # and could be handled without allocations/deallocations.
        self.buffer += data

        while len(self.buffer) >= self.chunk_size:
            chunk = self.buffer[:self.chunk_size]
            self.buffer = self.buffer[self.chunk_size:]

            # Detect the end of current silence
            if self.silence_detect is True:
                if any(chunk):
                    self.silence_detect = 0
                    print("Silence - end")
                else:
                    # Still silence
                    continue

            else:
                # Heuristic detection of silence start
                if chunk[0] == 0 and chunk[-1] == 0:
                    self.silence_detect += 1
                else:
                    self.silence_detect = 0

                # Silence too long - stop transmission
                if self.silence_detect > self.SILENCE_TRESHOLD:
                    if any(chunk): # Accurate check
                        self.silence_detect = 0
                    else:
                        print("Silence - start")
                        self.silence_detect = True
                        continue

            self.sample_queue.put_nowait(chunk)

        # Warning - might happen on slow UDP output sink
        if self.sample_queue.qsize() > 30:
            s = "WARNING: Samples in queue: %d - slow UDP transmission!"
            s = s % self.sample_queue.qsize()
            print(s)

    def connection_lost(self, exc):
        print("The pulse was lost. I should go.")
        loop = asyncio.get_event_loop()
        loop.call_soon_threadsafe(loop.stop)

    def decrement_chunk_size(self):
        "Decrement chunk size and flush chunks currently in queue"
        self.chunk_size -= 1
        self.chunk_size -= self.chunk_size % self.sample_size
        # Empty the queue
        while True:
            try:
                self.sample_queue.get_nowait()
            except asyncio.QueueEmpty:
                break
        return self.chunk_size + self.HEADER_SIZE

    def get_chunk_size(self):
        return self.chunk_size

    def get_next_chunk(self):
        return self.sample_queue.get()


class Packetizer:
    """Read chunks from queue, add timestamp marks and send over multicast."""

    HEADER_COMPRESSED_AUDIO = b'\x80\x00'
    HEADER_RAW_AUDIO = b'\x00\x00'
    HEADER_STATUS = b'\x40\x00'

    def __init__(self, reader, time_machine,
                 chunk_queue, latency_msec, audio_cfg, compress=False):
        self.reader = reader
        self.chunk_queue = chunk_queue
        self.time_machine = time_machine
        self.latency_msec = latency_msec
        self.compress = compress
        self.audio_cfg = audio_cfg

    def create_socket(self, channels, ttl, multicast_loop, broadcast):
        "Create a UDP multicast socket"
        import socket
        self.sock = socket.socket(socket.AF_INET,
                                  socket.SOCK_DGRAM,
                                  socket.IPPROTO_UDP)
        self.sock.setsockopt(socket.IPPROTO_IP,
                             socket.IP_MULTICAST_TTL,
                             ttl)

        if multicast_loop is True:
            self.sock.setsockopt(socket.IPPROTO_IP,
                                 socket.IP_MULTICAST_LOOP, 1)

        if broadcast is True:
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

        self.destinations = [
            (address, port)
            for address, port in channels
        ]

        IP_PMTUDISC_DO = 2
        IP_MTU_DISCOVER = 10

        # Set DF flag on IP packet (Don't Fragment) - fragmenting would be bad idea
        # it's way better to chunk the packets right.
        self.sock.setsockopt(socket.IPPROTO_IP, IP_MTU_DISCOVER, IP_PMTUDISC_DO)

    def _create_status_packet(self, chunk_no):
        "Format status packet"
        flags = Packetizer.HEADER_STATUS
        now = datetime.utcnow().timestamp()
        dgram = flags + struct.pack('dIHBBHH',
                                    now,
                                    chunk_no,
                                    self.audio_cfg['rate'],
                                    self.audio_cfg['sample'],
                                    self.audio_cfg['channels'],
                                    self.reader.get_chunk_size(),
                                    self.audio_cfg['latency_msec']
        )
        return dgram

    @asyncio.coroutine
    def packetize(self):
        "Read pre-chunked samples from queue and send them over UDP"
        start = time()
        # Numer of sent packets
        stat_pkts = 0
        # Chunk number as seen by receivers
        chunk_no = 0
        bytes_sent = 0
        bytes_raw = 0
        cancelled_compressions = 0

        # Current speed measurement
        recent = 0
        recent_bytes = 0
        recent_start = time()

        # For local playback
        if self.chunk_queue:
            cfg = self.audio_cfg.copy()
            cfg['chunk_size'] = 1500
            self.chunk_queue.chunk_list.append((self.chunk_queue.CMD_CFG,
                                                cfg))

        while True:
            # Block until samples are read by the reader.
            chunk = yield from self.reader.get_next_chunk()
            full_mark, mark = self.time_machine.get_timemark(self.latency_msec)

            if self.chunk_queue:
                item = (full_mark, chunk)
                self.chunk_queue.chunk_list.append((self.chunk_queue.CMD_AUDIO,
                                                    item))
                self.chunk_queue.chunk_available.set()


            chunk_len = len(chunk)
            if self.compress is not False:
                chunk_compressed = zlib.compress(chunk, self.compress)
                if len(chunk_compressed) < chunk_len:
                    # Go with compressed
                    dgram = Packetizer.HEADER_COMPRESSED_AUDIO + mark + chunk_compressed
                else:
                    # Cancel - compressed might not fit to packet
                    dgram = Packetizer.HEADER_RAW_AUDIO + mark + chunk
                    cancelled_compressions += 1
            else:
                dgram = b'\x00\x00' + mark + chunk

            dgram_len = len(dgram)
            chunk_no += 1
            recent += 1
            for destination in self.destinations:
                try:
                    self.sock.sendto(dgram, destination)
                    bytes_sent += dgram_len
                    recent_bytes += dgram_len
                    bytes_raw += chunk_len + 4
                    stat_pkts += 1
                except OSError as e:
                    import errno
                    if e.errno == errno.EMSGSIZE:
                        s = "WARNING: UDP datagram size (%d) is too big for your network MTU"
                        s = s % len(dgram)
                        print(s)
                        new_size = self.reader.decrement_chunk_size()
                        print("Trying MTU detection. New payload size is %d" % new_size)
                        break

            # Send small status datagram every 124 chunks - ~ 1 second
            # It's used to determine if some frames were lost on the network
            # and therefore if output buffer resync is required.
            # Contains the audio configuration too.
            if chunk_no % 124 == 0:
                dgram = self._create_status_packet(chunk_no)
                for destination in self.destinations:
                    self.sock.sendto(dgram, destination)

            if recent >= 100:
                # Main status line
                now = time()
                took_total = now - start
                took_recent = now - recent_start
                s = ("STATE: dsts=%d total: pkts=%d kB=%d time=%d "
                     "kB/s: avg=%.3f cur=%.3f")
                s = s % (
                    len(self.destinations),
                    stat_pkts,
                    bytes_sent / 1024, took_total,
                    bytes_sent / took_total / 1024,
                    recent_bytes / took_recent / 1024,
                )
                if self.compress:
                    s += ' compress_ratio=%.3f cancelled=%d'
                    s = s % (bytes_sent / bytes_raw, cancelled_compressions)
                print(s)

                recent_start = now
                recent_bytes = 0
                recent = 0

class ChunkQueue:
    "Queue of packets"

    CMD_AUDIO = 1
    CMD_DROPS = 2
    CMD_CFG = 3

    def __init__(self):
        # NOTE: On LAN an unsorted deque works for me. Might need
        # a packet ordering based on time mark eventually.
        self.chunk_list = deque()

        self.chunk_available = asyncio.Event()

        # When doing huge recovery - ignore few cached, out-of-date packets
        self.ignore_audio_packets = 0

    def init_queue(self):
        self.chunk_no = 0
        self.last_sender_chunk_no = None

    def do_recovery(self):
        "Flush the incoming, and probably stale, UDP buffer"
        # 60 == about 0.5s in default configuration
        self.ignore_audio_packets = 60
        self.last_sender_chunk_no = None
        self.chunk_no = 0


class Receiver(asyncio.DatagramProtocol):
    """
    Packet receiver

    - Receive packets
    - decode headers
    - store in chunk list.
    """

    def __init__(self, chunk_queue, time_machine, channel):
        # Store config
        self.channel = channel

        self.time_machine = time_machine

        self.chunk_queue = chunk_queue

        self.stat_network_latency = 0
        self.stat_network_drops = 0

        # Audio configuration sent by transmitter
        self.current_audio_cfg = None

        super().__init__()

    def connection_made(self, transport):
        "Configure multicast"
        sock = transport.get_extra_info('socket')
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # Check if address is multicast and join group.
        group, port = self.channel

        multicast = True
        octets = group.split('.')

        # Received audio chunk counter
        self.chunk_queue.init_queue()

        if len(octets) != 4:
            multicast = False
        else:
            try:
                o = int(octets[0])
                if not (o >= 224 and o <= 239):
                    multicast = False
            except ValueError:
                multicast = False

        # If not multicast - end
        if multicast is False:
            print("Assuming unicast reception on %s:%d" % (group, port))
            return

        # Multicast - join group
        print("Joining multicast group", group)

        group = socket.inet_aton(group)
        mreq = struct.pack('4sL', group, socket.INADDR_ANY)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

    def _handle_status(self, data):
        now = datetime.utcnow().timestamp()

        if len(data) < (2 + 20):
            print("WARNING: Status header too short")

        (sender_timestamp,
         sender_chunk_no,
         rate, sample,
         channels,
         chunk_size,
         latency) = struct.unpack('dIHBBHH',
                                  data[2:2 + 8+4+2+1+1+2+2])

        q = self.chunk_queue

        # Handle timestamp
        self.stat_network_latency = (now - sender_timestamp)

        # Handle audio configuration
        audio_cfg = {
            'rate': rate,
            'sample': sample,
            'channels': channels,
            'chunk_size': chunk_size,
            'latency_msec': latency,
        }
        if audio_cfg != self.current_audio_cfg:
            # If changed - sent further
            q.chunk_list.append((q.CMD_CFG, audio_cfg))
            self.current_audio_cfg = audio_cfg

        # Handle dropped packets

        # If this is first status packet
        # or low sender_chunk_no indicates that sender was restarted
        if q.last_sender_chunk_no is None or sender_chunk_no < 1500:
            q.last_sender_chunk_no = sender_chunk_no
            q.chunk_no = 0
            return

        # How many chunks were transmitted since previous status packet?
        chunks_sent = sender_chunk_no - q.last_sender_chunk_no
        dropped = chunks_sent - q.chunk_no

        q.last_sender_chunk_no = sender_chunk_no
        q.chunk_no = 0

        self.stat_network_drops += dropped
        if dropped < 0:
            print("WARNING: More pkts received than sent! "
                  "You are receiving multiple streams or duplicates.")
        elif dropped > 0:
            q.chunk_list.append((self.CMD_DROPS, dropped))
            q.chunk_available.set()

    def datagram_received(self, data, addr):
        "Handle incoming datagram - audio chunk, or status packet"
        header = data[:2]
        mark = data[2:4]
        chunk = data[4:]
        if header == Packetizer.HEADER_RAW_AUDIO:
            pass
        elif header == Packetizer.HEADER_COMPRESSED_AUDIO:
            try:
                chunk = zlib.decompress(chunk)
            except zlib.error:
                print("WARNING: Invalid compressed data - dropping")
                return
        elif header == Packetizer.HEADER_STATUS:
            # Status header!
            self._handle_status(data)
            return
        else:
            print("Invalid header!")
            return

        if self.chunk_queue.ignore_audio_packets != 0:
            self.chunk_queue.ignore_audio_packets -= 1
            return

        mark = self.time_machine.to_absolute_timestamp(mark)
        item = (mark, chunk)

        # Count received audio-chunks
        self.chunk_queue.chunk_no += 1

        self.chunk_queue.chunk_list.append((self.chunk_queue.CMD_AUDIO, item))
        self.chunk_queue.chunk_available.set()

    def error_received(self, exc):
        print('Error received:', exc)

    def connection_lost(self, exc):
        print("Socket closed, stop the event loop")
        loop = asyncio.get_event_loop()
        loop.stop()

class ChunkPlayer:
    "Play received audio and keep sync"

    def __init__(self, chunk_queue, receiver, tolerance,
                 sink_latency, latency,
                 buffer_size, device_index):
        # Our data source
        self.chunk_queue = chunk_queue

        # Required for showing unified stats.
        self.receiver = receiver

        # Configuration
        self.tolerance = tolerance
        self.sink_latency = sink_latency
        # Only needed if latency in system exceeds 2s
        self.latency = latency

        # Audio state
        self.audio_cfg = None
        self.buffer_size = buffer_size
        self.device_index = device_index
        self.stream = None

        # Generate silence frames (zeroed) of appropriate sizes for chunks
        self.silence_cache = None

        # Number of silent frames that need to be inserted to get in sync
        self.silence_to_insert = 0

        # Stats
        self.stat_time_drops = 0
        self.stat_output_delays = 0
        self.stat_total_delay = 0

    def clear_state(self):
        "Clear player queue"
        self.silence_to_insert = 0

        # Clear the chunk list, but preserve CFG commands
        cfg = None
        for cmd, item in self.chunk_queue.chunk_list:
            if cmd == self.chunk_queue.CMD_CFG:
                cfg = item
                break

        self.chunk_queue.chunk_list.clear()
        if cfg is not None:
            self.chunk_queue.chunk_list.append((self.chunk_queue.CMD_CFG, cfg))

        self.chunk_queue.do_recovery()

    def get_silent_chunk(self):
        "Generate and cache silent chunks"
        if self.silence_cache is not None:
            return self.silence_cache

        silent_chunk = b'\x00' * self.audio_cfg['chunk_size']
        self.silence_cache = silent_chunk
        return silent_chunk

    def _open_stream(self):
        import pyaudio

        assert self.stream is None
        self.pa = pyaudio.PyAudio()

        self.clear_state()

        # Open stream
        cfg = self.audio_cfg
        if cfg['sample'] == 24:
            frame_size = 3 * cfg['channels']
            format = pyaudio.paInt24
        else:
            frame_size = 2 * cfg['channels']
            format = pyaudio.paInt16

        frames_per_buffer = self.buffer_size

        queue_l = 1/cfg['rate'] * frames_per_buffer
        # That's untrue probably. There's probably more than one buffer (3 using ALSA I guess)
        # print("Output queue length is %.2fms" % (queue_l * 1000))

        stream = self.pa.open(output=True,
                              channels=cfg['channels'],
                              rate=cfg['rate'],
                              format=format,
                              frames_per_buffer=frames_per_buffer,
                              output_device_index=self.device_index)

        self.frame_size = frame_size
        self.chunk_frames = self.audio_cfg['chunk_size'] / frame_size
        self.stream = stream

    def _close_stream(self):
        self.stream.stop_stream()
        self.stream.close()
        self.pa.terminate()
        self.stream = None


    @asyncio.coroutine
    def chunk_player(self):
        "Reads asynchronously chunks from the list and plays them"

        cnt = 0

        # Chunk/s stat
        recent_start = time()
        recent = 0

        mid_tolerance = self.tolerance / 2
        one_msec = 1/1000.0

        max_delay = 5

        while True:
            if len(self.chunk_queue.chunk_list) == 0:

                if self.audio_cfg is not None:
                    print("Queue empty - waiting")

                self.chunk_queue.chunk_available.clear()
                yield from self.chunk_queue.chunk_available.wait()

                recent_start = time()
                recent = 0
                if self.audio_cfg is not None:
                    yield from asyncio.sleep(self.audio_cfg['latency_msec'] / 1000 / 4)
                    print("Got stream flowing. q_len=%d" % len(self.chunk_queue.chunk_list))
                continue

            cmd, item = self.chunk_queue.chunk_list.popleft()

            if cmd == self.chunk_queue.CMD_CFG:
                print("Got new configuration - opening audio stream")
                self.clear_state()
                self.audio_cfg = item
                if self.stream:
                    self._close_stream()
                self._open_stream()
                # Calculate maximum sensible delay in given configuration
                max_delay = (0.2 + self.sink_latency + self.audio_cfg['latency_msec'] / 1000)
                print("Assuming maximum chunk delay of %.2fms in this setup" % (max_delay * 1000))
                continue
            elif cmd == self.chunk_queue.CMD_DROPS:
                if item > 200:
                    print("Recovering after a huge packet loss of %d packets" % item)
                    self.clear_state()
                else:
                    # Just slowly resync
                    self.silence_to_insert += item
                continue

            # CMD_AUDIO

            if self.stream is None:
                # No output, no playing.
                continue

            mark, chunk = item
            desired_time = mark - self.sink_latency

            # 0) We got the next chunk to be played
            now = datetime.utcnow().timestamp()
            delay = desired_time - now

            self.stat_total_delay += delay

            recent += 1
            cnt += 1

            # Probabilistic drop of lagging chunks to get back on track.
            # Probability of drop is higher, the more chunk lags behind current
            # time. Similar to the RED algorithm in TCP congestion.
            if delay < -mid_tolerance:
                over = -delay - mid_tolerance
                prob = over / mid_tolerance
                if random.random() < prob:
                    s = "Drop chunk: q_len=%2d delay=%.3fms < 0. tolerance=%.3fms: P=%.2f"
                    s = s % (len(self.chunk_queue.chunk_list),
                             delay*1000, -self.tolerance*1000, prob)
                    print(s)
                    self.stat_time_drops += 1
                    continue

            elif delay > max_delay:
                # Probably we hanged for so long time that the time recovering
                # mechanism rolled over. Recover
                print("Huge recovery - delay of %.2f exceeds the max delay of %.2f" % (
                    delay, max_delay))
                self.clear_state()
                continue

            # If chunk is in the future - wait until it's within the tolerance
            elif delay > one_msec:
                to_wait = max(one_msec, delay - one_msec)
                yield from asyncio.sleep(to_wait)


            # Wait until we can write chunk into output buffer. This might
            # delay us too much - the probabilistic dropping mechanism will kick
            # in.
            times = 0
            while True:
                buffer_space = self.stream.get_write_available()
                if buffer_space < self.chunk_frames:
                    self.stat_output_delays += 1
                    yield from asyncio.sleep(max(one_msec, delay))
                    times += 1
                    if times > 100:
                        print("Hey, the output is STUCK!")
                        yield from asyncio.sleep(1)
                        break
                    continue
                self.stream.write(chunk)
                break

            # Main status line
            if recent > 200:
                latency = self.stream.get_output_latency()
                frames_in_chunk = len(chunk) / self.frame_size

                took = time() - recent_start
                chunks_per_s = recent / took

                if self.receiver is not None:
                    network_latency = self.receiver.stat_network_latency
                    network_drops = self.receiver.stat_network_drops
                else:
                    network_latency = 0
                    network_drops = 0

                s = ("STAT: chunks: q_len=%-3d bs=%4.1f "
                     "ch/s=%5.1f "
                     "net lat: %-5.1fms "
                     "avg_delay=%-5.2f drops: time=%d net=%d out_delay=%d")
                s = s % (
                    len(self.chunk_queue.chunk_list),
                    buffer_space / frames_in_chunk,
                    chunks_per_s,
                    1000.0 * network_latency,
                    1000.0 * self.stat_total_delay/cnt,
                    self.stat_time_drops,
                    network_drops,
                    self.stat_output_delays,
                )
                print(s)

                recent = 0
                recent_start = time()

                # Warnings
                if self.receiver is not None:
                    if self.receiver.stat_network_latency > 4:
                        print("WARNING: Your network latency seems HUGE. "
                              "Are the clocks synchronised?")
                    elif self.receiver.stat_network_latency < 0:
                        print("WARNING: You either exceeded the speed of "
                              "light or have unsynchronised clocks")


def _parse_arguments():
    "Parse program arguments"
    import argparse

    version = ".".join(str(p) for p in VERSION)

    dst=(
        "WaveSync %s - a multi-room sound synchronisation. "
        "https://github.com/blaa/WaveSync"
    )

    dst = dst % version
    p = argparse.ArgumentParser(description=dst)
    snd = p.add_argument_group('sender options')
    rcv = p.add_argument_group('receiver options')
    opt = p.add_argument_group('common')
    act = p.add_argument_group('actions')

    act.add_argument("--tx",
                     metavar="INPUT",
                     action="store",
                     default=None,
                     help="transmit sound from a given unix socket")

    act.add_argument("--rx",
                     action="store_true",
                     default=False,
                     help="receive sound and play it")

    snd.add_argument("--local-play",
                     action="store_true",
                     default=False,
                     help="play sound as well as transmitting it")

    snd.add_argument("--latency",
                     dest="latency_msec",
                     metavar="MSEC",
                     action="store",
                     default=1000,
                     type=int,
                     help="time to synchronise the outputs (default 1000). Pass to the receivers if over 2000")

    snd.add_argument("--payload-size",
                     metavar="BYTES",
                     action="store",
                     type=int,
                     default=1472, # although 1500 - 80 would be safer.
                     help="UDP payload size, (default is 1472)")

    snd.add_argument("--ttl",
                     metavar="TTL",
                     action="store",
                     type=int,
                     default=2,
                     help="multicast TTL (default 2)")

    snd.add_argument("--compress",
                     metavar="LEVEL",
                     action="store",
                     default=False,
                     type=int,
                     help="enable compression (level 1-9)")

    snd.add_argument("--no-loop",
                     dest="multicast_loop",
                     action="store_false",
                     default=True,
                     help="Do not loop multicast packets back to the sender")

    snd.add_argument("--broadcast",
                     action="store_true",
                     help="Use broadcast transmission")

    snd.add_argument("--rate",
                     dest="audio_rate",
                     metavar="Hz",
                     action="store",
                     type=int,
                     default=44100,
                     help="Set player rate (default 44100Hz)")

    snd.add_argument("--24bits",
                     dest="audio_sample",
                     action="store_true",
                     help="24bit samples (default 16)")

    snd.add_argument("--channels",
                     dest="audio_channels",
                     action="store",
                     type=int,
                     default=2,
                     help="Set number of audio channels (default 2 - stereo)")

    rcv.add_argument("--tolerance",
                     dest='tolerance_msec',
                     metavar="MSEC",
                     action="store",
                     type=int,
                     default=15,
                     help="play error tolerance (default 15ms)")

    rcv.add_argument("--sink-latency",
                     dest="sink_latency_msec",
                     metavar="MSEC",
                     action="store",
                     type=int,
                     default=0,
                     help="sink latency")

    rcv.add_argument("--buffer-size",
                     metavar="FRAMES",
                     action="store",
                     type=int,
                     default=8192,
                     help="size of local output buffer in frames (default 8192)")

    rcv.add_argument("--device-index",
                     metavar="NUMBER",
                     action="store",
                     type=int,
                     default=0,
                     help="audio device index for playback (default 0)")

    opt.add_argument("--channel",
                     dest="ip_list",
                     metavar="ADDRESS:PORT",
                     action="append",
                     default=[],
                     help="multicast group or a unicast address, "
                          "may be given multiple times with --tx")

    opt.add_argument("--sample-size",
                     metavar="BYTES",
                     action="store",
                     type=int,
                     default=4,
                     help="sample size in bytes (16-bit 2-channel = 4 bytes)")

    opt.add_argument("--debug",
                     action="store_true",
                     help="enable debugging code")

    args = p.parse_args()

    if (args.tx is None) == (args.rx is False):
        p.error('Exactly one action: --tx or --rx must be specified')

    if args.sink_latency_msec > args.latency_msec:
        p.error("Sink latency cannot exceed system latency! Leave some margin too.")

    if args.latency_msec >= 5000:
        print("WARNING: You seem to be using large latency")
    elif args.latency_msec >= 29000:
        p.error("Latency shouldn't exceed 29s (in fact, it should work with latency < 5000).")

    if not args.ip_list:
        args.ip_list.append('224.0.0.57:45300')

    if args.rx and len(args.ip_list) > 1:
        p.error('Receiver must have only a single channel (IP)')

    # Parse IP addresses
    parsed_ip_list = []
    for arg in args.ip_list:
        tmp = arg.split(':')
        if len(tmp) != 2:
            p.error('TX/RX channel not in format IP_ADDRESS:PORT: ' + arg)
        address, port = tmp

        try:
            port = int(port)
        except ValueError:
            p.error('Port is not a number in channel: ' + arg)

        parsed_ip_list.append((address, port))
    args.ip_list = parsed_ip_list

    return args


def start_tx(args, loop, time_machine):
    "Initialize sender"

    # Transmitted configuration
    audio_cfg = {
        'rate': args.audio_rate,
        'sample': 24 if args.audio_sample else 16,
        'channels': args.audio_channels,
        'latency_msec': args.latency_msec,
    }

    # Sound sample reader
    sample_reader = SampleReader()
    sample_reader.set_chunk_size(args.payload_size, args.sample_size)

    if args.local_play:
        chunk_queue = ChunkQueue()
        player = ChunkPlayer(chunk_queue,
                             receiver=None,
                             tolerance=args.tolerance_msec / 1000.0,
                             sink_latency=args.sink_latency_msec / 1000.0,
                             latency=args.latency_msec / 1000.0,
                             buffer_size=args.buffer_size,
                             device_index=args.device_index)
        play = player.chunk_player()
        asyncio.async(play)
    else:
        chunk_queue = None

    # Packet splitter / sender
    packetizer = Packetizer(sample_reader, time_machine,
                            chunk_queue,
                            args.latency_msec,
                            audio_cfg=audio_cfg,
                            compress=args.compress)

    packetizer.create_socket(args.ip_list,
                             args.ttl,
                             args.multicast_loop,
                             args.broadcast)

    connection = loop.create_unix_connection(lambda: sample_reader, args.tx)

    # Start loop
    asyncio.async(packetizer.packetize())
    asyncio.async(connection)
    loop.run_forever()



def start_rx(args, loop, time_machine):
    "Initialize receiver"

    # Network receiver with it's connection
    channel = args.ip_list[0]
    chunk_queue = ChunkQueue()
    receiver = Receiver(chunk_queue,
                        time_machine,
                        channel=channel)

    connection = loop.create_datagram_endpoint(lambda: receiver,
                                               family=socket.AF_INET,
                                               local_addr=channel)

    # Corouting pumping audio into PA
    player = ChunkPlayer(chunk_queue, receiver,
                         tolerance=args.tolerance_msec / 1000.0,
                         sink_latency=args.sink_latency_msec / 1000.0,
                         latency=args.latency_msec / 1000.0,
                         buffer_size=args.buffer_size,
                         device_index=args.device_index)

    play = player.chunk_player()

    tasks = asyncio.gather(connection, play)
    loop.run_until_complete(tasks)


def main():
    "Parse arguments and start the event loop"
    args = _parse_arguments()

    loop = asyncio.get_event_loop()

    if args.debug:
        loop.set_debug(True)

    time_machine = TimeMachine()

    try:
        if args.tx is not None:
            start_tx(args, loop, time_machine)
        elif args.rx:
            start_rx(args, loop, time_machine)
    finally:
        loop.close()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Quitting - user requested")
